# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/activesupport/all/activesupport.rbi
#
# activesupport-7.1.3

module ActiveSupport
  extend ActiveSupport::LazyLoadHooks
end
module ActiveSupport::DeepMergeable
  def deep_merge!(other, &block); end
  def deep_merge(other, &block); end
  def deep_merge?(other); end
end
class Hash
  def deep_merge?(other); end
  def except!(*keys); end
  def extract!(*keys); end
  def slice!(*keys); end
  include ActiveSupport::DeepMergeable
end
module ActiveSupport::LazyLoadHooks
  def execute_hook(name, base, options, block); end
  def on_load(name, options = nil, &block); end
  def run_load_hooks(name, base = nil); end
  def self.extended(base); end
  def with_execution_control(name, block, once); end
end
module ActiveSupport::Inflector
  def apply_inflections(word, rules, locale = nil); end
  def camelize(term, uppercase_first_letter = nil); end
  def classify(table_name); end
  def const_regexp(camel_cased_word); end
  def constantize(camel_cased_word); end
  def dasherize(underscored_word); end
  def deconstantize(path); end
  def demodulize(path); end
  def downcase_first(string); end
  def foreign_key(class_name, separate_class_name_and_id_with_underscore = nil); end
  def humanize(lower_case_and_underscored_word, capitalize: nil, keep_id_suffix: nil); end
  def inflections(locale = nil); end
  def ordinal(number); end
  def ordinalize(number); end
  def parameterize(string, separator: nil, preserve_case: nil, locale: nil); end
  def pluralize(word, locale = nil); end
  def safe_constantize(camel_cased_word); end
  def singularize(word, locale = nil); end
  def tableize(class_name); end
  def titleize(word, keep_id_suffix: nil); end
  def transliterate(string, replacement = nil, locale: nil); end
  def underscore(camel_cased_word); end
  def upcase_first(string); end
  extend ActiveSupport::Inflector
  extend ActiveSupport::Inflector
end
class ActiveSupport::Inflector::Inflections
  def acronym(word); end
  def acronyms; end
  def acronyms_camelize_regex; end
  def acronyms_underscore_regex; end
  def clear(scope = nil); end
  def define_acronym_regex_patterns; end
  def human(rule, replacement); end
  def humans; end
  def initialize; end
  def initialize_dup(orig); end
  def irregular(singular, plural); end
  def plural(rule, replacement); end
  def plurals; end
  def self.instance(locale = nil); end
  def self.instance_or_fallback(locale); end
  def singular(rule, replacement); end
  def singulars; end
  def uncountable(*words); end
  def uncountables; end
end
class ActiveSupport::Inflector::Inflections::Uncountables < Array
  def <<(*word); end
  def add(words); end
  def delete(entry); end
  def initialize; end
  def to_regex(string); end
  def uncountable?(str); end
end
module ActiveSupport::Multibyte
  def self.proxy_class; end
  def self.proxy_class=(klass); end
end
class String
  def camelcase(first_letter = nil); end
  def camelize(first_letter = nil); end
  def classify; end
  def constantize; end
  def dasherize; end
  def deconstantize; end
  def demodulize; end
  def downcase_first; end
  def foreign_key(separate_class_name_and_id_with_underscore = nil); end
  def humanize(capitalize: nil, keep_id_suffix: nil); end
  def is_utf8?; end
  def mb_chars; end
  def parameterize(separator: nil, preserve_case: nil, locale: nil); end
  def pluralize(count = nil, locale = nil); end
  def safe_constantize; end
  def singularize(locale = nil); end
  def tableize; end
  def titlecase(keep_id_suffix: nil); end
  def titleize(keep_id_suffix: nil); end
  def underscore; end
  def upcase_first; end
end
class Module
  def delegate(*methods, to: nil, prefix: nil, allow_nil: nil, private: nil); end
  def delegate_missing_to(target, allow_nil: nil); end
end
class Module::DelegationError < NoMethodError
end
module ActiveSupport::Notifications
  def self.instrument(name, payload = nil); end
  def self.instrumenter; end
  def self.monotonic_subscribe(pattern = nil, callback = nil, &block); end
  def self.notifier; end
  def self.notifier=(arg0); end
  def self.publish(name, *args); end
  def self.publish_event(event); end
  def self.registry; end
  def self.subscribe(pattern = nil, callback = nil, &block); end
  def self.subscribed(callback, pattern = nil, monotonic: nil, &block); end
  def self.unsubscribe(subscriber_or_name); end
end
class ActiveSupport::Notifications::Instrumenter
  def build_handle(name, payload); end
  def finish(name, payload); end
  def finish_with_state(listeners_state, name, payload); end
  def id; end
  def initialize(notifier); end
  def instrument(name, payload = nil); end
  def new_event(name, payload = nil); end
  def start(name, payload); end
  def unique_id; end
end
class ActiveSupport::Notifications::Instrumenter::LegacyHandle
  def finish; end
  def initialize(notifier, name, id, payload); end
  def start; end
end
class ActiveSupport::Notifications::Instrumenter::LegacyHandle::Wrapper
  def build_handle(name, id, payload); end
  def finish(*, **, &); end
  def initialize(notifier); end
  def start(*, **, &); end
end
class ActiveSupport::Notifications::Event
  def allocations; end
  def children; end
  def cpu_time; end
  def duration; end
  def end; end
  def finish!; end
  def idle_time; end
  def initialize(name, start, ending, transaction_id, payload); end
  def name; end
  def now; end
  def now_allocations; end
  def now_cpu; end
  def parent_of?(event); end
  def payload; end
  def payload=(arg0); end
  def record; end
  def start!; end
  def time; end
  def transaction_id; end
end
module ActiveSupport::Tryable
  def try!(*args, **, &block); end
  def try(*args, **, &block); end
end
class Object < BasicObject
  include ActiveSupport::Tryable
end
class Delegator < BasicObject
  include ActiveSupport::Tryable
end
class NilClass
  def try!(*); end
  def try(*); end
end
class ActiveSupport::Notifications::InstrumentationSubscriberError < RuntimeError
  def exceptions; end
  def initialize(exceptions); end
end
module ActiveSupport::Notifications::FanoutIteration
  def iterate_guarding_exceptions(collection); end
end
class ActiveSupport::Notifications::Fanout
  def all_listeners_for(name); end
  def build_handle(name, id, payload); end
  def clear_cache(key = nil); end
  def finish(name, id, payload, listeners = nil); end
  def groups_for(name); end
  def initialize; end
  def inspect; end
  def listeners_for(name); end
  def listening?(name); end
  def lock; end
  def locked?; end
  def publish(name, *args); end
  def publish_event(event); end
  def start(name, id, payload); end
  def subscribe(pattern = nil, callable = nil, monotonic: nil, &block); end
  def synchronize(&block); end
  def try_lock; end
  def unlock; end
  def unsubscribe(subscriber_or_name); end
  def wait; end
  include ActiveSupport::Notifications::FanoutIteration
  include Mutex_m
end
class ActiveSupport::Notifications::Fanout::BaseGroup
  def each(&block); end
  def initialize(listeners, name, id, payload); end
  include ActiveSupport::Notifications::FanoutIteration
end
class ActiveSupport::Notifications::Fanout::BaseTimeGroup < ActiveSupport::Notifications::Fanout::BaseGroup
  def finish(name, id, payload); end
  def start(name, id, payload); end
end
class ActiveSupport::Notifications::Fanout::MonotonicTimedGroup < ActiveSupport::Notifications::Fanout::BaseTimeGroup
  def now; end
end
class ActiveSupport::Notifications::Fanout::TimedGroup < ActiveSupport::Notifications::Fanout::BaseTimeGroup
  def now; end
end
class ActiveSupport::Notifications::Fanout::EventedGroup < ActiveSupport::Notifications::Fanout::BaseGroup
  def finish(name, id, payload); end
  def start(name, id, payload); end
end
class ActiveSupport::Notifications::Fanout::EventObjectGroup < ActiveSupport::Notifications::Fanout::BaseGroup
  def build_event(name, id, payload); end
  def finish(name, id, payload); end
  def start(name, id, payload); end
end
class ActiveSupport::Notifications::Fanout::Handle
  def ensure_state!(expected); end
  def finish; end
  def finish_with_values(name, id, payload); end
  def initialize(notifier, name, id, payload); end
  def start; end
  include ActiveSupport::Notifications::FanoutIteration
end
module ActiveSupport::Notifications::Fanout::Subscribers
  def self.new(pattern, listener, monotonic); end
end
class ActiveSupport::Notifications::Fanout::Subscribers::Matcher
  def ===(name); end
  def exclusions; end
  def initialize(pattern); end
  def pattern; end
  def self.wrap(pattern); end
  def unsubscribe!(name); end
end
class ActiveSupport::Notifications::Fanout::Subscribers::Matcher::AllMessages
  def ===(name); end
  def unsubscribe!(*); end
end
class ActiveSupport::Notifications::Fanout::Subscribers::Evented
  def delegate; end
  def group_class; end
  def initialize(pattern, delegate); end
  def pattern; end
  def publish(name, *args); end
  def publish_event(event); end
  def silenceable; end
  def silenced?(name); end
  def subscribed_to?(name); end
  def unsubscribe!(name); end
end
class ActiveSupport::Notifications::Fanout::Subscribers::Timed < ActiveSupport::Notifications::Fanout::Subscribers::Evented
  def group_class; end
  def publish(name, *args); end
end
class ActiveSupport::Notifications::Fanout::Subscribers::MonotonicTimed < ActiveSupport::Notifications::Fanout::Subscribers::Timed
  def group_class; end
end
class ActiveSupport::Notifications::Fanout::Subscribers::EventObject < ActiveSupport::Notifications::Fanout::Subscribers::Evented
  def group_class; end
  def publish_event(event); end
end

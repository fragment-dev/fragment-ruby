# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: false
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/net-http/all/net-http.rbi
#
# net-http-0.4.1

module Net
end
module Net::HTTPExceptions
  def data; end
  def initialize(msg, res); end
  def response; end
end
class Net::HTTPError < Net::ProtocolError
  include Net::HTTPExceptions
end
class Net::HTTPRetriableError < Net::ProtoRetriableError
  include Net::HTTPExceptions
end
class Net::HTTPClientException < Net::ProtoServerError
  include Net::HTTPExceptions
end
class Net::HTTPFatalError < Net::ProtoFatalError
  include Net::HTTPExceptions
end
module Net::HTTPHeader
  def [](key); end
  def []=(key, val); end
  def add_field(key, val); end
  def append_field_value(ary, val); end
  def basic_auth(account, password); end
  def basic_encode(account, password); end
  def canonical_each; end
  def capitalize(name); end
  def chunked?; end
  def connection_close?; end
  def connection_keep_alive?; end
  def content_length; end
  def content_length=(len); end
  def content_range; end
  def content_type; end
  def content_type=(type, params = nil); end
  def delete(key); end
  def each; end
  def each_capitalized; end
  def each_capitalized_name; end
  def each_header; end
  def each_key(&block); end
  def each_name(&block); end
  def each_value; end
  def fetch(key, *args, &block); end
  def form_data=(params, sep = nil); end
  def get_fields(key); end
  def initialize_http_header(initheader); end
  def key?(key); end
  def length; end
  def main_type; end
  def proxy_basic_auth(account, password); end
  def range; end
  def range=(r, e = nil); end
  def range_length; end
  def set_content_type(type, params = nil); end
  def set_field(key, val); end
  def set_form(params, enctype = nil, formopt = nil); end
  def set_form_data(params, sep = nil); end
  def set_range(r, e = nil); end
  def size; end
  def sub_type; end
  def to_hash; end
  def type_params; end
end
class Net::HTTPGenericRequest
  def []=(key, val); end
  def body; end
  def body=(str); end
  def body_exist?; end
  def body_stream; end
  def body_stream=(input); end
  def decode_content; end
  def encode_multipart_form_data(out, params, opt); end
  def exec(sock, ver, path); end
  def flush_buffer(out, buf, chunked_p); end
  def initialize(m, reqbody, resbody, uri_or_path, initheader = nil); end
  def inspect; end
  def method; end
  def path; end
  def quote_string(str, charset); end
  def request_body_permitted?; end
  def response_body_permitted?; end
  def send_request_with_body(sock, ver, path, body); end
  def send_request_with_body_data(sock, ver, path, params); end
  def send_request_with_body_stream(sock, ver, path, f); end
  def set_body_internal(str); end
  def supply_default_content_type; end
  def update_uri(addr, port, ssl); end
  def uri; end
  def wait_for_continue(sock, ver); end
  def write_header(sock, ver, path); end
  include Net::HTTPHeader
end
class Net::HTTPGenericRequest::Chunker
  def finish; end
  def initialize(sock); end
  def write(buf); end
end
class Net::HTTPRequest < Net::HTTPGenericRequest
  def initialize(path, initheader = nil); end
end
class Net::HTTP::Get < Net::HTTPRequest
end
class Net::HTTP::Head < Net::HTTPRequest
end
class Net::HTTP::Post < Net::HTTPRequest
end
class Net::HTTP::Put < Net::HTTPRequest
end
class Net::HTTP::Delete < Net::HTTPRequest
end
class Net::HTTP::Options < Net::HTTPRequest
end
class Net::HTTP::Trace < Net::HTTPRequest
end
class Net::HTTP::Patch < Net::HTTPRequest
end
class Net::HTTP::Propfind < Net::HTTPRequest
end
class Net::HTTP::Proppatch < Net::HTTPRequest
end
class Net::HTTP::Mkcol < Net::HTTPRequest
end
class Net::HTTP::Copy < Net::HTTPRequest
end
class Net::HTTP::Move < Net::HTTPRequest
end
class Net::HTTP::Lock < Net::HTTPRequest
end
class Net::HTTP::Unlock < Net::HTTPRequest
end
class Net::HTTPResponse
  def body; end
  def body=(value); end
  def body_encoding; end
  def body_encoding=(value); end
  def check_bom(str); end
  def code; end
  def code_type; end
  def decode_content; end
  def decode_content=(arg0); end
  def detect_encoding(str, encoding = nil); end
  def entity; end
  def error!; end
  def error_type; end
  def extracting_encodings_from_meta_elements(value); end
  def get_attribute(ss); end
  def header; end
  def http_version; end
  def ignore_eof; end
  def ignore_eof=(arg0); end
  def inflater; end
  def initialize(httpv, code, msg); end
  def inspect; end
  def message; end
  def msg; end
  def procdest(dest, block); end
  def read_body(dest = nil, &block); end
  def read_body_0(dest); end
  def read_chunked(dest, chunk_data_io); end
  def read_header; end
  def reading_body(sock, reqmethodallowbody); end
  def response; end
  def scanning_meta(str); end
  def self.body_permitted?; end
  def self.each_response_header(sock); end
  def self.exception_type; end
  def self.read_new(sock); end
  def self.read_status_line(sock); end
  def self.response_class(code); end
  def sniff_encoding(str, encoding = nil); end
  def stream_check; end
  def uri; end
  def uri=(uri); end
  def value; end
  include Net::HTTPHeader
end
class Net::HTTPResponse::Inflater
  def bytes_inflated; end
  def finish; end
  def inflate_adapter(dest); end
  def initialize(socket); end
  def read(clen, dest, ignore_eof = nil); end
  def read_all(dest); end
end
class Net::HTTPUnknownResponse < Net::HTTPResponse
end
class Net::HTTPInformation < Net::HTTPResponse
end
class Net::HTTPSuccess < Net::HTTPResponse
end
class Net::HTTPRedirection < Net::HTTPResponse
end
class Net::HTTPClientError < Net::HTTPResponse
end
class Net::HTTPServerError < Net::HTTPResponse
end
class Net::HTTPContinue < Net::HTTPInformation
end
class Net::HTTPSwitchProtocol < Net::HTTPInformation
end
class Net::HTTPProcessing < Net::HTTPInformation
end
class Net::HTTPEarlyHints < Net::HTTPInformation
end
class Net::HTTPOK < Net::HTTPSuccess
end
class Net::HTTPCreated < Net::HTTPSuccess
end
class Net::HTTPAccepted < Net::HTTPSuccess
end
class Net::HTTPNonAuthoritativeInformation < Net::HTTPSuccess
end
class Net::HTTPNoContent < Net::HTTPSuccess
end
class Net::HTTPResetContent < Net::HTTPSuccess
end
class Net::HTTPPartialContent < Net::HTTPSuccess
end
class Net::HTTPMultiStatus < Net::HTTPSuccess
end
class Net::HTTPAlreadyReported < Net::HTTPSuccess
end
class Net::HTTPIMUsed < Net::HTTPSuccess
end
class Net::HTTPMultipleChoices < Net::HTTPRedirection
end
class Net::HTTPMovedPermanently < Net::HTTPRedirection
end
class Net::HTTPFound < Net::HTTPRedirection
end
class Net::HTTPSeeOther < Net::HTTPRedirection
end
class Net::HTTPNotModified < Net::HTTPRedirection
end
class Net::HTTPUseProxy < Net::HTTPRedirection
end
class Net::HTTPTemporaryRedirect < Net::HTTPRedirection
end
class Net::HTTPPermanentRedirect < Net::HTTPRedirection
end
class Net::HTTPBadRequest < Net::HTTPClientError
end
class Net::HTTPUnauthorized < Net::HTTPClientError
end
class Net::HTTPPaymentRequired < Net::HTTPClientError
end
class Net::HTTPForbidden < Net::HTTPClientError
end
class Net::HTTPNotFound < Net::HTTPClientError
end
class Net::HTTPMethodNotAllowed < Net::HTTPClientError
end
class Net::HTTPNotAcceptable < Net::HTTPClientError
end
class Net::HTTPProxyAuthenticationRequired < Net::HTTPClientError
end
class Net::HTTPRequestTimeout < Net::HTTPClientError
end
class Net::HTTPConflict < Net::HTTPClientError
end
class Net::HTTPGone < Net::HTTPClientError
end
class Net::HTTPLengthRequired < Net::HTTPClientError
end
class Net::HTTPPreconditionFailed < Net::HTTPClientError
end
class Net::HTTPPayloadTooLarge < Net::HTTPClientError
end
class Net::HTTPURITooLong < Net::HTTPClientError
end
class Net::HTTPUnsupportedMediaType < Net::HTTPClientError
end
class Net::HTTPRangeNotSatisfiable < Net::HTTPClientError
end
class Net::HTTPExpectationFailed < Net::HTTPClientError
end
class Net::HTTPMisdirectedRequest < Net::HTTPClientError
end
class Net::HTTPUnprocessableEntity < Net::HTTPClientError
end
class Net::HTTPLocked < Net::HTTPClientError
end
class Net::HTTPFailedDependency < Net::HTTPClientError
end
class Net::HTTPUpgradeRequired < Net::HTTPClientError
end
class Net::HTTPPreconditionRequired < Net::HTTPClientError
end
class Net::HTTPTooManyRequests < Net::HTTPClientError
end
class Net::HTTPRequestHeaderFieldsTooLarge < Net::HTTPClientError
end
class Net::HTTPUnavailableForLegalReasons < Net::HTTPClientError
end
class Net::HTTPInternalServerError < Net::HTTPServerError
end
class Net::HTTPNotImplemented < Net::HTTPServerError
end
class Net::HTTPBadGateway < Net::HTTPServerError
end
class Net::HTTPServiceUnavailable < Net::HTTPServerError
end
class Net::HTTPGatewayTimeout < Net::HTTPServerError
end
class Net::HTTPVersionNotSupported < Net::HTTPServerError
end
class Net::HTTPVariantAlsoNegotiates < Net::HTTPServerError
end
class Net::HTTPInsufficientStorage < Net::HTTPServerError
end
class Net::HTTPLoopDetected < Net::HTTPServerError
end
class Net::HTTPNotExtended < Net::HTTPServerError
end
class Net::HTTPNetworkAuthenticationRequired < Net::HTTPServerError
end
module Net::HTTP::ProxyDelta
  def conn_address; end
  def conn_port; end
  def edit_path(path); end
end
class Net::HTTP < Net::Protocol
  def D(msg); end
  def active?; end
  def addr_port; end
  def address; end
  def begin_transport(req); end
  def ca_file; end
  def ca_file=(arg0); end
  def ca_path; end
  def ca_path=(arg0); end
  def cert; end
  def cert=(arg0); end
  def cert_store; end
  def cert_store=(arg0); end
  def ciphers; end
  def ciphers=(arg0); end
  def close_on_empty_response; end
  def close_on_empty_response=(arg0); end
  def conn_address; end
  def conn_port; end
  def connect; end
  def continue_timeout; end
  def continue_timeout=(sec); end
  def copy(path, initheader = nil); end
  def debug(msg); end
  def delete(path, initheader = nil); end
  def do_finish; end
  def do_start; end
  def edit_path(path); end
  def end_transport(req, res); end
  def extra_chain_cert; end
  def extra_chain_cert=(arg0); end
  def finish; end
  def get(path, initheader = nil, dest = nil, &block); end
  def get2(path, initheader = nil, &block); end
  def head(path, initheader = nil); end
  def head2(path, initheader = nil, &block); end
  def ignore_eof; end
  def ignore_eof=(arg0); end
  def initialize(address, port = nil); end
  def inspect; end
  def ipaddr; end
  def ipaddr=(addr); end
  def keep_alive?(req, res); end
  def keep_alive_timeout; end
  def keep_alive_timeout=(arg0); end
  def key; end
  def key=(arg0); end
  def local_host; end
  def local_host=(arg0); end
  def local_port; end
  def local_port=(arg0); end
  def lock(path, body, initheader = nil); end
  def max_retries; end
  def max_retries=(retries); end
  def max_version; end
  def max_version=(arg0); end
  def min_version; end
  def min_version=(arg0); end
  def mkcol(path, body = nil, initheader = nil); end
  def move(path, initheader = nil); end
  def on_connect; end
  def open_timeout; end
  def open_timeout=(arg0); end
  def options(path, initheader = nil); end
  def patch(path, data, initheader = nil, dest = nil, &block); end
  def peer_cert; end
  def port; end
  def post(path, data, initheader = nil, dest = nil, &block); end
  def post2(path, data, initheader = nil, &block); end
  def propfind(path, body = nil, initheader = nil); end
  def proppatch(path, body, initheader = nil); end
  def proxy?; end
  def proxy_address; end
  def proxy_address=(arg0); end
  def proxy_from_env=(arg0); end
  def proxy_from_env?; end
  def proxy_pass; end
  def proxy_pass=(arg0); end
  def proxy_port; end
  def proxy_port=(arg0); end
  def proxy_uri; end
  def proxy_user; end
  def proxy_user=(arg0); end
  def proxyaddr; end
  def proxyport; end
  def put(path, data, initheader = nil); end
  def put2(path, data, initheader = nil, &block); end
  def read_timeout; end
  def read_timeout=(sec); end
  def request(req, body = nil, &block); end
  def request_get(path, initheader = nil, &block); end
  def request_head(path, initheader = nil, &block); end
  def request_post(path, data, initheader = nil, &block); end
  def request_put(path, data, initheader = nil, &block); end
  def response_body_encoding; end
  def response_body_encoding=(value); end
  def self.Proxy(p_addr = nil, p_port = nil, p_user = nil, p_pass = nil); end
  def self.default_port; end
  def self.get(uri_or_host, path_or_headers = nil, port = nil); end
  def self.get_print(uri_or_host, path_or_headers = nil, port = nil); end
  def self.get_response(uri_or_host, path_or_headers = nil, port = nil, &block); end
  def self.http_default_port; end
  def self.https_default_port; end
  def self.is_version_1_1?; end
  def self.is_version_1_2?; end
  def self.new(address, port = nil, p_addr = nil, p_port = nil, p_user = nil, p_pass = nil, p_no_proxy = nil); end
  def self.newobj(*, **); end
  def self.post(url, data, header = nil); end
  def self.post_form(url, params); end
  def self.proxy_address; end
  def self.proxy_class?; end
  def self.proxy_pass; end
  def self.proxy_port; end
  def self.proxy_user; end
  def self.socket_type; end
  def self.start(address, *arg, &block); end
  def self.version_1_1?; end
  def self.version_1_2; end
  def self.version_1_2?; end
  def send_entity(path, data, initheader, dest, type, &block); end
  def send_request(name, path, data = nil, header = nil); end
  def set_debug_output(output); end
  def ssl_timeout; end
  def ssl_timeout=(arg0); end
  def ssl_version; end
  def ssl_version=(arg0); end
  def sspi_auth(req); end
  def sspi_auth?(res); end
  def start; end
  def started?; end
  def trace(path, initheader = nil); end
  def transport_request(req); end
  def unescape(value); end
  def unlock(path, body, initheader = nil); end
  def use_ssl=(flag); end
  def use_ssl?; end
  def verify_callback; end
  def verify_callback=(arg0); end
  def verify_depth; end
  def verify_depth=(arg0); end
  def verify_hostname; end
  def verify_hostname=(arg0); end
  def verify_mode; end
  def verify_mode=(arg0); end
  def write_timeout; end
  def write_timeout=(sec); end
end
module Net::NetPrivate
end
class Net::HTTPBadResponse < StandardError
end
class Net::HTTPHeaderSyntaxError < StandardError
end

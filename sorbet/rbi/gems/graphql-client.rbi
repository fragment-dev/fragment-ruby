# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/graphql-client/all/graphql-client.rbi
#
# graphql-client-0.20.0

module GraphQL
end
class GraphQL::Client
  def allow_dynamic_queries; end
  def allow_dynamic_queries=(arg0); end
  def create_operation(fragment, filename = nil, lineno = nil); end
  def deep_freeze_json_object(obj); end
  def deep_stringify_keys(obj); end
  def document; end
  def document_tracking_enabled; end
  def document_tracking_enabled=(arg0); end
  def enforce_collocated_callers; end
  def execute; end
  def find_definition_dependencies(node); end
  def get_type(type_name); end
  def initialize(schema:, execute: nil, enforce_collocated_callers: nil); end
  def parse(str, filename = nil, lineno = nil); end
  def possible_types(type_condition = nil); end
  def query(definition, variables: nil, context: nil); end
  def schema; end
  def self.dump_schema(schema, io = nil, context: nil); end
  def self.load_schema(schema); end
  def sliced_definitions(document_dependencies, doc, source_location:); end
  def types; end
  extend GraphQL::Client::CollocatedEnforcement
end
module GraphQL::Client::TypeStack
  def argument_definitions; end
  def directive_definitions; end
  def field_definitions; end
  def initialize(document, schema:, **rest); end
  def object_types; end
  def on_argument(node, parent); end
  def on_directive(node, parent); end
  def on_field(node, parent); end
  def on_fragment_definition(node, parent); end
  def on_fragment_spread(node, parent); end
  def on_inline_fragment(node, parent); end
  def on_operation_definition(node, parent); end
  def path; end
  def schema; end
end
class GraphQL::Client::Error < StandardError
end
class GraphQL::Client::InvariantError < GraphQL::Client::Error
end
class GraphQL::Client::ImplicitlyFetchedFieldError < NoMethodError
end
class GraphQL::Client::UnfetchedFieldError < NoMethodError
end
class GraphQL::Client::UnimplementedFieldError < NoMethodError
end
class GraphQL::Client::NonCollocatedCallerError < GraphQL::Client::Error
end
module GraphQL::Client::CollocatedEnforcement
  def allow_noncollocated_callers; end
  def enforce_collocated_callers(mod, methods, path); end
  def verify_collocated_path(location, path, method = nil); end
  extend GraphQL::Client::CollocatedEnforcement
end
module GraphQL::Client::DefinitionVariables
  def self.operation_variables(schema, document, definition_name = nil); end
  def self.variable_node(type); end
  def self.variables(schema, document, definition_name = nil); end
end
class GraphQL::Client::DefinitionVariables::VariablesVisitor < GraphQL::Language::Visitor
  def initialize(document, schema:, **rest); end
  def on_variable_identifier(node, parent); end
  def variables; end
end
class GraphQL::Client::HashWithIndifferentAccess
  def [](key); end
  def convert_value(key); end
  def each(*args, **, &block); end
  def each_key(&block); end
  def empty?(*args, **, &block); end
  def fetch(key, *args, &block); end
  def has_key?(key); end
  def include?(key); end
  def initialize(hash = nil); end
  def inspect(*args, **, &block); end
  def key?(key); end
  def keys(*args, **, &block); end
  def length(*args, **, &block); end
  def member?(key); end
  def size(*args, **, &block); end
  def to_h(*args, **, &block); end
  def to_hash(*args, **, &block); end
  def values(*args, **, &block); end
  extend Forwardable
  include Enumerable
end
class GraphQL::Client::Errors
  def [](key); end
  def all; end
  def blank?; end
  def count; end
  def details; end
  def each; end
  def empty?; end
  def filter_by_path(field); end
  def has_key?(field); end
  def include?(field); end
  def initialize(errors = nil, path = nil, all = nil); end
  def inspect; end
  def key?(field); end
  def keys; end
  def messages; end
  def self.normalize_error_paths(data = nil, errors = nil); end
  def size; end
  def values; end
  include Enumerable
end
module GraphQL::Client::Schema
  def self.class_for(schema, type, cache); end
  def self.generate(schema); end
end
module GraphQL::Client::Schema::BaseType
  def cast(value, errors); end
  def schema_module; end
  def schema_module=(arg0); end
  def to_list_type; end
  def to_non_null_type; end
  def type; end
end
class GraphQL::Client::Schema::PossibleTypes
  def cast(value, errors); end
  def initialize(type, types); end
  def possible_types; end
  include GraphQL::Client::Schema::BaseType
end
module GraphQL::Client::Schema::ObjectType
  def cast(value, errors); end
  def define_class(definition, ast_nodes); end
  def define_field(name, type); end
  def gather_selections(fields, definition, selected_ast_node); end
  def self.new(type, fields = nil); end
end
class GraphQL::Client::Schema::ObjectType::WithDefinition
  def defined_fields; end
  def definition; end
  def fields; end
  def initialize(klass, defined_fields, definition, spreads); end
  def klass; end
  def new(data = nil, errors = nil); end
  def spreads; end
  def type; end
  include GraphQL::Client::Schema::BaseType
  include GraphQL::Client::Schema::ObjectType
end
class GraphQL::Client::Schema::ObjectClass
  def _definer; end
  def _spreads; end
  def errors; end
  def has_attribute?(attr); end
  def initialize(data = nil, errors = nil, definer = nil); end
  def inspect; end
  def method_missing(name, *args); end
  def read_attribute(attr, type); end
  def respond_to_missing?(name, priv); end
  def source_definition; end
  def to_h; end
  def verify_collocated_path; end
end
class GraphQL::Client::Definition < Module
  def cast_object(obj); end
  def client; end
  def definition_name; end
  def definition_node; end
  def document; end
  def indexes; end
  def initialize(client:, document:, source_document:, ast_node:, source_location:); end
  def new(obj, errors = nil); end
  def schema_class; end
  def self.for(ast_node:, **kargs); end
  def source_document; end
  def source_location; end
end
class GraphQL::Client::Definition::DefinitionVisitor < GraphQL::Language::Visitor
  def definitions; end
  def flatten_spreads(node); end
  def get_spreads(node); end
  def initialize(doc); end
  def on_field(node, parent); end
  def on_fragment_definition(node, parent); end
  def on_inline_fragment(node, parent); end
  def on_operation_definition(node, parent); end
  def spreads; end
end
class GraphQL::Client::FragmentDefinition < GraphQL::Client::Definition
  def new(obj, *args); end
end
class GraphQL::Client::OperationDefinition < GraphQL::Client::Definition
  def operation_name; end
end
module GraphQL::Client::DocumentTypes
  def self.analyze_types(schema, document); end
end
class GraphQL::Client::DocumentTypes::AnalyzeTypesVisitor < GraphQL::Language::Visitor
  def fields; end
  def initialize(document, schema:, **rest); end
  def on_field(node, parent); end
  def on_fragment_definition(node, parent); end
  def on_inline_fragment(node, parent); end
  def on_operation_definition(node, parent); end
end
module GraphQL::Client::QueryTypename
  def self.insert_typename_fields(document, types: nil); end
  def self.node_flatten_selections(selections); end
end
class GraphQL::Client::QueryTypename::InsertTypenameVisitor < GraphQL::Language::Visitor
  def add_typename(node, parent); end
  def initialize(document, types:); end
  def on_field(node, parent); end
  def on_fragment_definition(node, parent); end
  def on_operation_definition(node, parent); end
end
class GraphQL::Client::Response
  def data; end
  def errors; end
  def extensions; end
  def initialize(hash, data: nil, errors: nil, extensions: nil); end
  def original_hash; end
  def to_h; end
end
class GraphQL::Client::Schema::EnumType < Module
  def [](value); end
  def cast(value, _errors = nil); end
  def define_class(definition, ast_nodes); end
  def initialize(type); end
  include GraphQL::Client::Schema::BaseType
end
class GraphQL::Client::Schema::EnumType::EnumValue < String
  def initialize(obj, enum_value, enum); end
  def method_missing(method_name, *args); end
  def respond_to_missing?(method_name, include_private = nil); end
end
class GraphQL::Client::Schema::IncludeDirective
  def cast(value, errors); end
  def initialize(of_klass); end
  def of_klass; end
  include GraphQL::Client::Schema::BaseType
end
class GraphQL::Client::Schema::InterfaceType < Module
  def define_class(definition, ast_nodes); end
  def initialize(type); end
  def new(types); end
  include GraphQL::Client::Schema::BaseType
end
class GraphQL::Client::List < Array
  def errors; end
  def initialize(values, errors = nil); end
end
class GraphQL::Client::Schema::ListType
  def cast(values, errors); end
  def initialize(of_klass); end
  def of_klass; end
  def to_list_type; end
  include GraphQL::Client::Schema::BaseType
end
class GraphQL::Client::Schema::NonNullType
  def cast(value, errors); end
  def initialize(of_klass); end
  def of_klass; end
  def to_non_null_type; end
  include GraphQL::Client::Schema::BaseType
end
class GraphQL::Client::Schema::ScalarType
  def cast(value, _errors = nil); end
  def define_class(definition, ast_nodes); end
  def initialize(type); end
  include GraphQL::Client::Schema::BaseType
end
class GraphQL::Client::Schema::SkipDirective
  def cast(value, errors); end
  def initialize(of_klass); end
  def of_klass; end
  include GraphQL::Client::Schema::BaseType
end
class GraphQL::Client::Schema::UnionType < Module
  def define_class(definition, ast_nodes); end
  def initialize(type); end
  def new(types); end
  include GraphQL::Client::Schema::BaseType
end
module GraphQL::Client::Schema::ClassMethods
  def define_class(definition, ast_nodes, type); end
  def directives; end
  def get_class(type_name); end
  def normalize_type_name(type_name); end
  def set_class(type_name, klass); end
end
class GraphQL::Client::DynamicQueryError < GraphQL::Client::Error
end
class GraphQL::Client::NotImplementedError < GraphQL::Client::Error
end
class GraphQL::Client::ValidationError < GraphQL::Client::Error
end
class GraphQL::Client::RenameNodeVisitor < GraphQL::Language::Visitor
  def initialize(document, definitions:); end
  def on_fragment_definition(node, _parent); end
  def on_fragment_spread(node, _parent); end
  def on_operation_definition(node, _parent); end
  def rename_node(node); end
end
module GraphQL::Client::LazyName
  def _definition=(arg0); end
  def name; end
end
class GraphQL::Client::GatherNamesVisitor < GraphQL::Language::Visitor
  def initialize(node); end
  def names; end
  def on_fragment_spread(node, parent); end
end
class GraphQL::Client::HTTP
  def connection; end
  def execute(document:, operation_name: nil, variables: nil, context: nil); end
  def headers(_context); end
  def initialize(uri, &block); end
  def uri; end
end
